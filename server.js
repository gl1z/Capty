require('dotenv').config();
const express      = require('express');
const path         = require('path');
const fs           = require('fs');
const os           = require('os');
const { execFile } = require('child_process');
const rateLimit    = require('express-rate-limit');
const OpenAI       = require('openai');

const app    = express();
const PORT   = process.env.PORT || 3000;
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// ─── Security headers ──────────────────────────────────────────────────────
app.use((req, res, next) => {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'no-referrer');
    res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
    next();
});

app.use(express.json({ limit: '1mb' }));  // was 50mb — way too high, 1mb is plenty for text

// ─── Rate limiting ─────────────────────────────────────────────────────────
const limiter = rateLimit({
    windowMs: 60 * 1000,
    max: 15,
    standardHeaders: true,
    legacyHeaders: false,
    message: { error: 'Too many requests. Please wait a moment.' },
});

// Stricter limit for expensive AI endpoints
const aiLimiter = rateLimit({
    windowMs: 60 * 1000,
    max: 5,
    standardHeaders: true,
    legacyHeaders: false,
    message: { error: 'AI request limit reached. Wait a minute.' },
});

app.use('/api/', limiter);
app.use(express.static(path.join(__dirname)));

// ─── Helper: run yt-dlp ─────────────────────────────────────────────────────
function runYtDlp(args) {
    return new Promise((resolve, reject) => {
        execFile('yt-dlp', args, { maxBuffer: 10 * 1024 * 1024 }, (err, stdout, stderr) => {
            if (err) {
                console.log('yt-dlp stderr:', stderr);
                reject(new Error(stderr || err.message));
            } else {
                resolve(stdout);
            }
        });
    });
}

// ─── Input validation ──────────────────────────────────────────────────────
function isValidVideoId(id) {
    return typeof id === 'string' && /^[A-Za-z0-9_-]{11}$/.test(id);
}

function isValidLangCode(lang) {
    return typeof lang === 'string' && /^[a-zA-Z]{2}(-[a-zA-Z]{2,10})?$/.test(lang);
}

// ─── Language config ────────────────────────────────────────────────────────
const LANG_NAMES = {
    en: 'English', es: 'Spanish', de: 'German', ja: 'Japanese',
    zh: 'Chinese', ru: 'Russian', fr: 'French', pt: 'Portuguese',
    ko: 'Korean', ar: 'Arabic', hi: 'Hindi', it: 'Italian',
    tr: 'Turkish', pl: 'Polish', nl: 'Dutch', sv: 'Swedish',
    'pt-BR': 'Portuguese (Brazil)', 'zh-Hans': 'Chinese (Simplified)',
    'zh-Hant': 'Chinese (Traditional)', 'es-419': 'Spanish (Latin America)',
    'de-DE': 'German (Germany)',
};

const ALLOWED_LANGS = new Set([
    'en', 'es', 'de', 'ja', 'zh', 'ru',
    'pt-BR', 'es-419', 'de-DE', 'zh-Hans', 'zh-Hant',
]);

const TRANSLATE_LANGS = [
    { code: 'es', name: 'Spanish' },
    { code: 'fr', name: 'French' },
    { code: 'de', name: 'German' },
    { code: 'it', name: 'Italian' },
    { code: 'pt', name: 'Portuguese' },
    { code: 'ru', name: 'Russian' },
    { code: 'ja', name: 'Japanese' },
    { code: 'ko', name: 'Korean' },
    { code: 'zh', name: 'Chinese (Simplified)' },
    { code: 'ar', name: 'Arabic' },
    { code: 'hi', name: 'Hindi' },
    { code: 'tr', name: 'Turkish' },
    { code: 'pl', name: 'Polish' },
    { code: 'nl', name: 'Dutch' },
    { code: 'sv', name: 'Swedish' },
];

const VALID_TRANSLATE_CODES = new Set(TRANSLATE_LANGS.map(l => l.code));

function getLangName(code) {
    return LANG_NAMES[code] || code;
}

// ─── API: GET /api/transcript?id=VIDEO_ID ───────────────────────────────────
app.get('/api/transcript', async (req, res) => {
    const { id } = req.query;

    if (!isValidVideoId(id)) {
        return res.status(400).json({ error: 'Invalid video ID.' });
    }

    try {
        const url    = `https://www.youtube.com/watch?v=${id}`;
        const output = await runYtDlp(['--dump-json', '--skip-download', url]);
        const info   = JSON.parse(output);
        const tracks = [];

        if (info.subtitles) {
            for (const lang of Object.keys(info.subtitles)) {
                if (ALLOWED_LANGS.has(lang)) {
                    tracks.push({
                        languageCode: lang,
                        name: getLangName(lang),
                        isAutoGenerated: false,
                    });
                }
            }
        }

        if (info.automatic_captions) {
            const origLang = info.language || 'en';
            if (!tracks.find(t => t.languageCode === origLang)) {
                tracks.push({
                    languageCode: origLang,
                    name: getLangName(origLang) + ' (auto)',
                    isAutoGenerated: true,
                });
            }
        }

        if (tracks.length === 0) {
            return res.json({ tracks: [], whisperAvailable: true });
        }

        console.log(`Found ${tracks.length} tracks for ${id}`);
        res.json({ tracks, whisperAvailable: false });

    } catch (err) {
        console.log('Transcript error:', err.message);
        res.status(500).json({ error: 'Failed to fetch video info.' });  // don't leak internal errors
    }
});

// ─── API: GET /api/caption?id=VIDEO_ID&lang=LANG ────────────────────────────
app.get('/api/caption', async (req, res) => {
    const { id, lang } = req.query;

    if (!isValidVideoId(id)) return res.status(400).json({ error: 'Invalid video ID.' });

    const language = (lang && isValidLangCode(lang)) ? lang : 'en';
    const url      = `https://www.youtube.com/watch?v=${id}`;
    const tmpFile  = path.join(os.tmpdir(), `capty-${id}-${Date.now()}`);

    try {
        await runYtDlp([
            '--write-sub', '--write-auto-sub',
            '--sub-lang', language,
            '--sub-format', 'vtt/srv1/best',
            '--skip-download',
            '-o', tmpFile,
            url,
        ]);

        let subContent = '';
        const exts = [`.${language}.vtt`, `.${language}.srv1`, `.${language}.json3`, `.${language}.srt`];

        for (const ext of exts) {
            const filePath = tmpFile + ext;
            if (fs.existsSync(filePath)) {
                subContent = fs.readFileSync(filePath, 'utf8');
                fs.unlinkSync(filePath);
                break;
            }
        }

        if (!subContent) throw new Error('No subtitle file produced.');

        const text = parseSubtitleToText(subContent);
        if (!text) throw new Error('Could not parse subtitles.');

        res.json({ text, translateLangs: TRANSLATE_LANGS });

    } catch (err) {
        console.log('Caption error:', err.message);
        res.status(500).json({ error: 'Failed to load transcript.' });
    }
});

// ─── API: POST /api/whisper ─────────────────────────────────────────────────
app.post('/api/whisper', aiLimiter, async (req, res) => {
    const { id } = req.body;

    if (!isValidVideoId(id)) {
        return res.status(400).json({ error: 'Invalid video ID.' });
    }

    const url     = `https://www.youtube.com/watch?v=${id}`;
    const tmpFile = path.join(os.tmpdir(), `capty-whisper-${id}-${Date.now()}`);

    try {
        console.log(`Downloading audio for Whisper: ${id}`);

        await runYtDlp([
            '--extract-audio',
            '--audio-format', 'mp3',
            '--audio-quality', '5',
            '--max-filesize', '25m',
            '-o', `${tmpFile}.%(ext)s`,
            url,
        ]);

        const audioPath = `${tmpFile}.mp3`;

        if (!fs.existsSync(audioPath)) {
            throw new Error('Audio download failed.');
        }

        const fileSize = fs.statSync(audioPath).size;
        console.log(`Audio downloaded: ${(fileSize / 1024 / 1024).toFixed(2)} MB`);

        if (fileSize > 25 * 1024 * 1024) {
            fs.unlinkSync(audioPath);
            return res.status(400).json({ error: 'Audio too large (max 25MB). Try a shorter video.' });
        }

        const transcription = await openai.audio.transcriptions.create({
            file: fs.createReadStream(audioPath),
            model: 'whisper-1',
            response_format: 'text',
        });

        fs.unlinkSync(audioPath);

        console.log(`Whisper success for ${id}: ${transcription.length} chars`);
        res.json({ text: transcription, translateLangs: TRANSLATE_LANGS });

    } catch (err) {
        try { fs.unlinkSync(`${tmpFile}.mp3`); } catch (_) {}
        console.log('Whisper error:', err.message);
        res.status(500).json({ error: 'Transcription failed. Try again.' });
    }
});

// ─── API: POST /api/translate ───────────────────────────────────────────────
app.post('/api/translate', aiLimiter, async (req, res) => {
    const { text, targetLang } = req.body;

    if (!text || typeof text !== 'string') {
        return res.status(400).json({ error: 'Missing text.' });
    }

    if (!targetLang || !VALID_TRANSLATE_CODES.has(targetLang)) {
        return res.status(400).json({ error: 'Invalid target language.' });
    }

    // Cap text length to prevent abuse (roughly ~2 hours of transcript)
    const MAX_CHARS = 100_000;
    const trimmedText = text.slice(0, MAX_CHARS);

    const langName = TRANSLATE_LANGS.find(l => l.code === targetLang)?.name || targetLang;

    try {
        console.log(`Translating to ${langName} (${trimmedText.length} chars)`);

        const completion = await openai.chat.completions.create({
            model: 'gpt-4o-mini',
            messages: [
                {
                    role: 'system',
                    content: `You are a professional translator. Translate the following transcript text to ${langName}. 
                    Return only the translated text with no explanations, no notes, no formatting — just the translation.
                    Preserve the natural flow of the text.`,
                },
                {
                    role: 'user',
                    content: trimmedText,
                },
            ],
            temperature: 0.3,
        });

        const translated = completion.choices[0].message.content;
        console.log(`Translation done: ${translated.length} chars`);

        res.json({ text: translated });

    } catch (err) {
        console.log('Translation error:', err.message);
        res.status(500).json({ error: 'Translation failed. Try again.' });
    }
});

// ─── Parse VTT/SRT/XML to plain text ────────────────────────────────────────
function parseSubtitleToText(content) {
    if (content.includes('<text')) {
        const segments = [];
        let m;
        const pattern = /<text[^>]*>([\s\S]*?)<\/text>/g;
        while ((m = pattern.exec(content)) !== null) {
            const text = m[1]
                .replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>')
                .replace(/&#39;/g, "'").replace(/&quot;/g, '"')
                .replace(/\n/g, ' ').trim();
            if (text) segments.push(text);
        }
        return segments.join(' ');
    }

    content = content.replace(/^WEBVTT[\s\S]*?\n\n/, '');
    const lines = content.split('\n');
    const textLines = [];
    const seen = new Set();

    for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        if (/^\d+$/.test(trimmed)) continue;
        if (/-->/.test(trimmed)) continue;
        if (/^NOTE|^STYLE|^Kind:|^Language:/.test(trimmed)) continue;

        let cleaned = trimmed
            .replace(/<[^>]+>/g, '')
            .replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>')
            .replace(/&#39;/g, "'").replace(/&quot;/g, '"').replace(/&nbsp;/g, ' ')
            .trim();

        if (cleaned && !seen.has(cleaned)) {
            seen.add(cleaned);
            textLines.push(cleaned);
        }
    }

    return textLines.join(' ').replace(/\s+/g, ' ').trim();
}

app.listen(PORT, () => {
    console.log(`Capty running → http://localhost:${PORT}`);
});