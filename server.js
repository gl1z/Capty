const express    = require('express');
const path       = require('path');
const fs         = require('fs');
const os         = require('os');
const { execFile } = require('child_process');
const rateLimit  = require('express-rate-limit');

const app  = express();
const PORT = process.env.PORT || 3000;

const limiter = rateLimit({
    windowMs: 60 * 1000,
    max: 15,
    standardHeaders: true,
    legacyHeaders: false,
    message: { error: 'Too many requests. Please wait a moment.' },
});

app.use('/api/', limiter);
app.use(express.static(path.join(__dirname)));

// ─── Helper: run yt-dlp ─────────────────────────────────────────────────────
function runYtDlp(args) {
    return new Promise((resolve, reject) => {
        execFile('yt-dlp', args, { maxBuffer: 10 * 1024 * 1024 }, (err, stdout, stderr) => {
            if (err) {
                console.log('yt-dlp stderr:', stderr);
                reject(new Error(stderr || err.message));
            } else {
                resolve(stdout);
            }
        });
    });
}

// ─── Language config ────────────────────────────────────────────────────────
const LANG_NAMES = {
    en: 'English', es: 'Spanish', de: 'German', ja: 'Japanese',
    zh: 'Chinese', ru: 'Russian', fr: 'French', pt: 'Portuguese',
    ko: 'Korean', ar: 'Arabic', hi: 'Hindi', it: 'Italian',
    tr: 'Turkish', pl: 'Polish', nl: 'Dutch', sv: 'Swedish',
    'pt-BR': 'Portuguese (Brazil)', 'zh-Hans': 'Chinese (Simplified)',
    'zh-Hant': 'Chinese (Traditional)', 'es-419': 'Spanish (Latin America)',
    'de-DE': 'German (Germany)',
};

// Only show these languages in the UI
const ALLOWED_LANGS = new Set([
    'en', 'es', 'de', 'ja', 'zh', 'ru',
    'pt-BR', 'es-419', 'de-DE', 'zh-Hans', 'zh-Hant',
]);

function getLangName(code) {
    return LANG_NAMES[code] || code;
}

// ─── API: GET /api/transcript?id=VIDEO_ID ───────────────────────────────────
app.get('/api/transcript', async (req, res) => {
    const { id } = req.query;

    if (!id || !/^[A-Za-z0-9_-]{11}$/.test(id)) {
        return res.status(400).json({ error: 'Invalid video ID.' });
    }

    try {
        const url = `https://www.youtube.com/watch?v=${id}`;

        const output = await runYtDlp([
            '--dump-json',
            '--skip-download',
            url,
        ]);

        const info = JSON.parse(output);
        const tracks = [];

        // 1. Manual/uploaded subtitles — only allowed languages
        if (info.subtitles) {
            for (const lang of Object.keys(info.subtitles)) {
                if (ALLOWED_LANGS.has(lang)) {
                    tracks.push({
                        languageCode: lang,
                        name: getLangName(lang),
                        isAutoGenerated: false,
                    });
                }
            }
        }

        // 2. Auto-generated — only the original language (if it's allowed)
        if (info.automatic_captions) {
            const origLang = info.language || 'en';
            if (!tracks.find(t => t.languageCode === origLang)) {
                tracks.push({
                    languageCode: origLang,
                    name: getLangName(origLang) + ' (auto)',
                    isAutoGenerated: true,
                });
            }
        }

        if (tracks.length === 0) {
            throw new Error('No captions found for this video.');
        }

        console.log(`Found ${tracks.length} tracks for ${id}:`, tracks.map(t => t.name).join(', '));
        res.json({ tracks });
    } catch (err) {
        console.log('Transcript error:', err.message);
        res.status(500).json({ error: err.message });
    }
});

// ─── API: GET /api/caption?id=VIDEO_ID&lang=LANG ────────────────────────────
app.get('/api/caption', async (req, res) => {
    const { id, lang } = req.query;

    if (!id) {
        return res.status(400).json({ error: 'Missing video ID.' });
    }

    const language = lang || 'en';
    const url = `https://www.youtube.com/watch?v=${id}`;
    const tmpFile = path.join(os.tmpdir(), `capty-${id}-${Date.now()}`);

    try {
        await runYtDlp([
            '--write-sub',
            '--write-auto-sub',
            '--sub-lang', language,
            '--sub-format', 'vtt/srv1/best',
            '--skip-download',
            '-o', tmpFile,
            url,
        ]);

        let subContent = '';
        const possibleExts = [
            `.${language}.vtt`,
            `.${language}.srv1`,
            `.${language}.json3`,
            `.${language}.srt`,
        ];

        for (const ext of possibleExts) {
            const filePath = tmpFile + ext;
            if (fs.existsSync(filePath)) {
                subContent = fs.readFileSync(filePath, 'utf8');
                fs.unlinkSync(filePath);
                console.log(`Read subtitle: ${ext} (${subContent.length} chars)`);
                break;
            }
        }

        if (!subContent) {
            throw new Error('yt-dlp did not produce a subtitle file.');
        }

        const text = parseSubtitleToText(subContent);

        if (!text) {
            throw new Error('Could not parse subtitle content.');
        }

        console.log(`Success! ${text.length} chars for ${id} (${language})`);
        res.json({ text });
    } catch (err) {
        console.log('Caption error:', err.message);
        res.status(500).json({ error: err.message });
    }
});

// ─── Parse VTT/SRT/XML to plain text ───────────────────────────────────────
function parseSubtitleToText(content) {
    if (content.includes('<text')) {
        const segments = [];
        let m;
        const pattern = /<text[^>]*>([\s\S]*?)<\/text>/g;
        while ((m = pattern.exec(content)) !== null) {
            const text = m[1]
                .replace(/&amp;/g, '&')
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&#39;/g, "'")
                .replace(/&quot;/g, '"')
                .replace(/\n/g, ' ')
                .trim();
            if (text) segments.push(text);
        }
        return segments.join(' ');
    }

    content = content.replace(/^WEBVTT[\s\S]*?\n\n/, '');
    const lines = content.split('\n');
    const textLines = [];
    const seen = new Set();

    for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        if (/^\d+$/.test(trimmed)) continue;
        if (/-->/.test(trimmed)) continue;
        if (/^NOTE|^STYLE|^Kind:|^Language:/.test(trimmed)) continue;

        let cleaned = trimmed
            .replace(/<[^>]+>/g, '')
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&#39;/g, "'")
            .replace(/&quot;/g, '"')
            .replace(/&nbsp;/g, ' ')
            .trim();

        if (cleaned && !seen.has(cleaned)) {
            seen.add(cleaned);
            textLines.push(cleaned);
        }
    }

    return textLines.join(' ').replace(/\s+/g, ' ').trim();
}

app.listen(PORT, () => {
    console.log(`Capty running → http://localhost:${PORT}`);
});